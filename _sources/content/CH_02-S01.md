---
jupytext:
  cell_metadata_filter: -all
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Introducción al lenguaje C


```{admonition} Objetivos
* Conocer las generalidades del lenguaje de programación C.
* Conocer la estructura de un programa en C.
* Introducir el uso de las funciones y establecer cómo se realiza el paso de parámetros a funciones.
```

## 1. Formato típico de un programa en C

En su forma más básica un programa en C tiene la siguiente estructura:

```{code-block} c
/** Directivas del preprocesador */
// Librerías 
#include <libreriaSistema>
#include "libreriaUsuario"

// Macros y constantes con define
#define CTE VALOR_CTE

/* Variables globales*/
tipo1 varG1_1, varG2_1, ...;
tipo2 varG1_2, varG2_2, ...;
...

/* Función principal (Primera en ser llamada)*/
int main(int argc, char *argv[]) {
  /** Variables locales */
  tipo1 varL1_1, varL2_1, ...;
  tipo2 varL1_2, varL2_2, ...;
  ...
  /** Instrucciones */
  ...
  código
  ...
  return 0;
}
```

Como se puede notar, la forma es similar a la que se emplea en cualquier otro lenguaje. A continuación se muestra, con un breve ejemplo un caso de aplicación de la plantilla anterior.

### Ejemplos 

1. Hacer un programa que despliegue Hello world en pantalla:
   * Empleando java.
   * Empleando C.
  
   **Solución**:

   * **Empleando java**: a continuación se muestra el código solución ([ex1_ch2_S01.java](./local/code/ex1_ch2_S01.java)) en java ([simulación](https://pythontutor.com/render.html#code=public%20class%20Hello%20%7B%0A%20%20public%20static%20void%20main%28String%5B%5D%20args%29%20%7B%0A%20%20%20%20System.out.println%28%22Hello%20world%22%29%3B%0A%20%20%7D%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=java&rawInputLstJSON=%5B%5D&textReferences=false)):
  
     ```{code-block} java
     public class Hello {
       public static void main(String[] args) {
         System.out.println("Hello world");
       }
     }
     ```

   * **Empleando C**: en el enlace solución en C se encuentra el código C ([ex1_ch2_S01.c](./local/code/ex1_ch2_S01.c)) que implementa lo solicitado ([simulación](https://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28int%20argc,%20char%20*argv%5B%5D%29%20%7B%0A%20%20printf%28%22%25s%22,%22Hello,%20World%22%29%3B%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false)):
  
     ```{code-block} c
     #include <stdio.h>

     int main(int argc, char *argv[]) {
       printf("%s","Hello, World");
       return 0;
     }
     ```

     A modo de repaso, se muestran los comandos empleados para compilar y ejecutar el programa en C:

     ```
     $ gcc -Wall ex1_ch2_S01.c -o hello.out
     $ ls
     hello.c  hello.out
     $ ./hello.out
     Hello, World
     ```

## 2. Tipos de Datos

Los tipos de datos básicos incorporados en C son los enteros, los reales y los tipo carácter. En la siguiente tabla se resumen éstos:

{numref}`Tabla 1` Tipos de datos primitivos en C
| Tipo de dato             | Tamaño (en bytes) | Rango                     | Especificador de formato |
|--------------------------|-------------------|---------------------------|--------------------------|
| ```short (short int)```                   | 2    | -32768 to 32767       | ```%hd```                |
| ```unsigned short (unsigned short int)``` | 2    | 0 to 65535            | ```%hu```                |
| ```unsigned (unsigned int)```             | 4    | 0 to 4294967295           | ```%u```             |
| ```int```                                 | 4    | 2147483648 to 2147483647  | ```%d```             |
| ```long (long int)```                     | 4    | 2147483648 to 2147483647  | ```%ld```            |
| ```unsigned long (unsigned long int)```   | 4    | 0 to 4294967295           | ```%lu```            |
| ```long long (long long int)```           | 8    | -(2^63) to (2^63)-1       | ```%lld```           |
| ```unsigned long long (unsigned long long int)``` | 8  | 0 to 18446744073709551615 | ```%llu```     |
| ```char (signed char)```                  | 1     | -128 to 127              | ```%c```             |
| ```unsigned char```                       | 1     | 0 to 255                 | ```%c```             |
| ```float```                               | 4     |                          | ```%f```             |
| ```double```                              | 8     |                          | ```%lf```            |
| ```long double```                         | 12    |                          | ```%Lf```            |

El manejo de los tipos de datos en C es muy similar al que se hace en java. Cabe resaltar que de los tipos de datos enteros, el tipo **```char```** se utiliza para representar caracteres de modo que las constantes tipo **```char```** pueden ser:
1. Caracteres encerrados entre comillas (```'A'```, ```'b'```, ```'p'```) asociados a un valor ascii.
2. Caracteres no imprimibles (tabulación, avance de página) los cuales se representan con secuencias de escape (```'\n'```, ```'\t'```). La siguiente tabla muestra algunos de estos caracteres:

{numref}`Tabla 2` Secuencias de escape en C
| Carácter de escape          | Singnificado | Código ASCII                   |
|-----------------------------|-------------------|---------------------------|
| ```\a```                    | Carácter de alerta (timbre)     | ```7```     |
| ```\b```                    | Retroceso de espacio            | ```8```     |
| ```\f```                    | Avance de página                | ```12```    |
| ```\n```                    | Nueva línea                     | ```10```    |
| ```\r```                    | Retorno de carro                | ```13```    |
| ```\t```                    | Tabulación horizontal           | ```9```     |
| ```\v```                    | Tabulación vertical             | ```11```    |
| ```\\```                    | Backslash ( ```\``` ).          | ```92```    |
| ```\?```                    | Interrogación ( ```?``` ).      | ```63```    |
| ```\'```                    | Comilla sencilla ( ```'``` ).   | ```39```    |
| ```\"```                    | Comillas dobles.                | ```34```    |
| ```\0nn```                  | Número octal.                   |             |
| ```\Xnn```                  | Número hexadecimal              |             |
| ```\0```                    | Carácter nulo o terminación de cadena  |      |


La equivalencia entre un carácter específico y su valor ascii se puede encontrar en una tabla ascii como la mostrada en el siguiente [enlace](http://www.fceia.unr.edu.ar/~ifc/apuntes/tascii.pdf).

### 2.1. Variables 

Una declaración indica el tipo de variable y le sirve al compilador para determinar la cantidad de memoria requerida para almacenar la variable deseada. El formato básico para declarar una variable es:

```{code-block} c
tipo var1, var2, ...;
```

Si la declaración produce también un almacenamiento (inicialización), entonces es una definición.

```{code-block} c
tipo var = valor inicial;
```


```{note}
* Todas las variables en C se declaran o definen antes de ser utilizadas, de lo contrario el compilador arrojará un error de variable no declarada.
* En esta sección se hace referencia sólo a las variables primitivas (```char```, ```int```, ```float```, ```double```, et.), cuando las variables son compuestas (arrays, cadenas de caracteres, matrices, ...) la inicializacion es diferente (este tema será abordado más adelante en el curso).
```

#### Ejemplos


1. A continuación se muestran varias declaraciones de variables, note que la forma es similar a la empleada en java:
   
   ```{code-block} c
   int i, j, k;
   float length, height;
   char midinit;
   float total = 16.78;
   int a = 1, b = 2;
   char ac = '@';
   const IVA = 19
   ```

   En el siguiente [enlace](https://goo.gl/cgydMU) puede hacer la simulacion del código anterior (note que las variables no inicializadas no aparecen desplegadas).

   ```{important} 
   La palabra reservada **```const```** (**```final```** en el caso de java) permite definir determinadas variables con valores constantes que no se pueden modificar.
   ```

### 2.2. Cadenas de caracteres

En C una cadena de caracteres (C String) no es un tipo de dato primitivo. En C se requiere usar un **arreglo** de caracteres (datos primitivos tipo char) cada vez que se requiera utilizar un **String**. Existen varias formas de declarar cadenas de caracteres:
1. Indicando el máximo número de carácteres en la definición:

   ```{code-block} c
   char nombreCadena[TAM];
   ```
2. Inicializando la cadena de carácteres de modo que el compilador pueda deducir su tamaño:

   ```{code-block} c
   char nombreCadena[] = "Contenido_de_la_cadena";
   ```

3. Definiendo el tamaño e inicializando:
   
   ```{code-block} c
   char nombreCadena[TAM] = "Contenido_de_la_cadena";
   ```

En una cadena de carácteres el último carácter útil es el carácter ```NULL``` (```\0```). El cual se incluye de manera automática para marcar el final de la cadena.


#### Ejemplos

1. Declarar una cadena llamada temp de 5 bytes cuyo contenido inicial sea *Hot*:

   ```{code-block} c
   char temp[5] = "Hot";
   ```
   
   El resultado en memoria puede ser visto en el siguiente [enlace](https://pythontutor.com/render.html#code=int%20main%28%29%20%7B%0A%20%20char%20temp%5B5%5D%20%3D%20%22Hot%22%3B%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false)

  
   <img src="./local/img/CH_02-S01-fig1.png" alt="representacion cadena">   


   Es importante resaltar que el programador debe asegurarse que la cadena de caracteres sea lo bastante grande para el uso deseado. Vemos que **```temp```** mantiene 4 caracteres, 3 de la palabra ```Hot``` más el carácter ```NULL```(```\0```). 


2. Se tienen la siguientes declaraciones ([simulación](ttps://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20char%20s1%5B6%5D%3B%0A%20%20char%20s2%5B5%5D%20%3D%20%22Hola%22%3B%0A%20%20char%20s3%5B%5D%20%3D%20%22zzz%22%3B%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false)):
   
   ```{code-block} c
   #include <stdio.h>

   int main() {
   char s1[6];
   char s2[5] = "Hola";
   char s3[] = "zzz";
   return 0;
   }
   ```

   Responda las siguientes preguntas:
   * ¿Cuál es el tamaño de cada una de las cadenas?
   * ¿Cuál es el contenido almacenado en cada una?

## 3. Entrada y salida estándar

En C la entrada y salida de texto se abstrae como streams o flujos de caracteres, no importa de dónde se origine el flujo o hacia a donde se dirija. Un flujo de texto, es una secuencia de caracteres dividida en líneas en la cual cada línea consiste de cero o más caracteres seguidos por un carácter de nueva línea.

En C las funciones de E/S y  las estructuras de datos usadas por esas funciones se encuentran declaradas en el archivo de cabecera **```<stdio.h>```**. Para el correcto funcionamiento del código es necesario incluir dicho archivo mediante la directiva del preprocesador **```#include```**, pues en caso contrario, puede funcionar de forma incorrecta, e incluso, puede llegar a dar errores de compilación.

La biblioteca **```stdio.h```** provee un conjunto de funciones para leer y escribir desde la consola. A continuación veremos algunas:

### Funcion ```printf```

La forma de la función se muestra a continuacion:

```{code-block} c
int printf(const char *format[,argumento,...]);
```

La función ```printf()``` se usa para escribir cualquier tipo de dato a la consola. Se conoce como salida formateada pues convierte, formatea, e imprime sus argumentos ```(arg1, arg2, ...)``` en la salida estándar. Para ello toma el formato establecido por el usuario en el argumento **format** (ver en la tabla 1 la columna **especificador de formato** asociada a cada tipo de dato).

Para informacion adicional puede consultar el siguiente [enlace](http://c.conclase.net/librerias/?ansifun=printf#inicio)

Por ejemplo suponiendo que se tiene el siguiente fragmento de código en C: 

```{code-block} c
printf("Color %s, Number %d, Float %5.2f\n", "red", 12345, 3.14);
```

La salida en pantalla será:

```
Color red, Number 12345, Float 3.14
```

Observe el siguiente codigo para comprender lo anterior ([simulación](https://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20printf%28%22Color%20%25s,%20Number%20%25d,%20Float%20%255.2f%5Cn%22,%20%22red%22,%2012345,%203.14%29%3B%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false)):

```{code-block} c
#include <stdio.h>

int main() {
  printf("Color %s, Number %d, Float %5.2f\n", "red", 12345, 3.14);
  return 0;
}
```

Notará que la parte asociada a especificador de formato (parte precedida por ```%``` en el primer argumento de la función ```printf```) se reemplaza por el respectivo valor asociado a la variable o constante. Como recordatorio, presentamos en la siguiente tabla los especificadores de formato más comunes:

{numref}`Tabla 3` Especificadores de formato más comunes en C
|Especificador de formato  | Tipo de dato |
|--------------------------|--------------|
| ```%d```                 |```int```   |
| ```%c```                 |```char```   |
| ```%s```                 |```char[]``` (cadena de caracteres)   |
| ```%f```                 |```float```   |
| ```%lf```                |```double```   |
| ```%e```                 |```float``` (El resultado se muestra en notación exponencial)   |
| ```%u```                 |```unsigned```   |
| ```%o```                 |```unsigned``` (el resultado se muestra en formato octal)   |
| ```%x```                 |```unsigned``` (el resultado se muestra en formato hexadecimal)   |

**Ejemplo**

Dado el siguiente fragmento de código ([simulación](https://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20printf%28%22ABC%22%29%3B%0A%20%20printf%28%22%5Cn%22%29%3B%0A%20%20printf%28%22---%5Cn%22%29%3B%0A%20%20printf%28%22%25d%5Cn%22,5%29%3B%0A%20%20printf%28%22---%5Cn%22%29%3B%0A%20%20printf%28%22%25c%20%25c%20%25c%5Cn%22,'A','B','C'%29%3B%0A%20%20printf%28%22---%5Cn%22%29%3B%0A%20%20printf%28%22From%20sea%20%22%29%3B%0A%20%20printf%28%22to%20shining%20%22%29%3B%0A%20%20printf%28%22C%5Cn%22%29%3B%0A%20%20printf%28%22---%5Cn%22%29%3B%0A%20%20float%20leg1%20%3D%20200.3,%20leg2%20%3D%20357.4%3B%0A%20%20printf%28%22If%20was%20%25f%20miles%5Cn%22,%20leg1%20%2B%20leg2%29%3B%0A%20%20printf%28%22---%5Cn%22%29%3B%0A%20%20int%20num1%20%3D%2010,%20num2%20%3D%2033%3B%0A%20%20printf%28%22%25d%5Ct%25d%5Cn%22,%20num1,%20num2%29%3B%0A%20%20printf%28%22---%5Cn%22%29%3B%0A%20%20float%20big%20%3D%2011e%2B23%3B%0A%20%20printf%28%22%25e%5Cn%22,%20big%29%3B%0A%20%20printf%28%22---%5Cn%22%29%3B%0A%20%20printf%28%22%25c%5Cn%22,'%3F'%29%3B%0A%20%20printf%28%22%25d%5Cn%22,'%3F'%29%3B%0A%20%20printf%28%22---%5Cn%22%29%3B%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false)). ¿Cual es su salida en pantalla?

```{code-block} c
#include <stdio.h>

int main() {
  printf("ABC");
  printf("\n");
  printf("---\n");
  printf("%d\n",5);
  printf("---\n");
  printf("%c %c %c\n",'A','B','C');
  printf("---\n");
  printf("From sea ");
  printf("to shining ");
  printf("C\n");
  printf("---\n");
  float leg1 = 200.3, leg2 = 357.4;
  printf("If was %f miles\n", leg1 + leg2);
  printf("---\n");
  int num1 = 10, num2 = 33;
  printf("%d\t%d\n", num1, num2);
  printf("---\n");
  float big = 11e+23;
  printf("%e\n", big);
  printf("---\n");
  printf("%c\n",'?');
  printf("%d\n",'?');
  printf("---\n");
  return 0;
}
```

El comportamiendo del especificador dependerá del tipo de dato tal y como se resume en las siguiente tablas segun el tipo de dato a imprimir.

#### Caso 1 - Datos enteros y caracter

{numref}`Tabla 4` Usando especificadores para datos tipo char e int

|Especificador de formato  | Tipo de dato |
|----------------|--------------------------|
| ```%[alineación][ancho]c``` | ```char```   |
| ```%[alineación][ancho]d``` | ```int``` |

La salida formateada permite un mayor control de la apariencia de la salida en pantalla, ya que es posible controlar que tantas columnas serán usadas a la salida del contenido de una variable particular al especificar el ancho del campo.

En lo que respecta a la alineación y para todos los casos cuando el símbolo es un menos (```-```) la alineación será a la izquierda, por otro lado si no hay símbolo, la alineación será a la derecha. Tambien, si se desea colocar ceros en vez de espacios, se debe colocar un cero (```0```) antes del campo ancho ancho. Por ejemplo: ```%04d```.


**Ejemplo**

Dado el siguiente fragmento de código ([simulación](https://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20char%20lett%3D'w'%3B%0A%20%20int%20i%3D1,j%3D29%3B%0A%20%20printf%20%28%22%25c%5Cn%22,lett%29%3B%0A%20%20printf%20%28%22%254c%5Cn%22,lett%29%3B%0A%20%20printf%20%28%22%25-3c%5Cn%5Cn%22,lett%29%3B%0A%20%20printf%20%28%22%25d%5Cn%22,i%29%3B%0A%20%20printf%20%28%22%25d%5Cn%22,j%29%3B%0A%20%20printf%20%28%22%2510d%5Cn%22,j%29%3B%0A%20%20printf%20%28%22%25010d%5Cn%22,j%29%3B%0A%20%20printf%20%28%22%25-010d%5Cn%22,j%29%3B%0A%20%20printf%20%28%22%252o%5Cn%22,j%29%3B%0A%20%20printf%20%28%22%252x%5Cn%22,j%29%3B%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false)). ¿Cual es su salida en pantalla?

```{code-block} c
#include <stdio.h>

int main() {
  char lett='w';
  int i=1,j=29;
  printf ("%c\n",lett);
  printf ("%4c\n",lett);
  printf ("%-3c\n\n",lett);
  printf ("%d\n",i);
  printf ("%d\n",j);
  printf ("%10d\n",j);
  printf ("%010d\n",j);
  printf ("%-010d\n",j);
  printf ("%2o\n",j);
  printf ("%2x\n",j);
  return 0;
}
```

#### Caso 2 - Datos reales

{numref}`Tabla 5` Usando especificadores para datos tipo float (también aplica a los demas tipos de datos reales)

|Especificador de formato  | Tipo de dato | Ejemplo | Resultado |
|----------------|--------------------------|----|---|
| ```%[alineación][ancho].[decimales]f``` | ```float```   | ```printf("%10.4f",4.0/3.0)```|```_ _ _ _1.3333``` |
| ```%[alineación][ancho].[decimales]e``` | ```float```   | ```printf("%10.4e",4.0/3.0)```|```_1.333e+10```|

**Ejemplo**

Dado el siguiente fragmento de código ([simulación](https://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20float%20x%3D333.123456%3B%0A%20%20double%20y%3D333.1234567890123456%3B%0A%20%20printf%28%22%25f%5Cn%22,x%29%3B%0A%20%20printf%28%22%25.1f%5Cn%22,x%29%3B%0A%20%20printf%28%22%2520.3f%5Cn%22,x%29%3B%0A%20%20printf%28%22%25-20.3f%5Cn%22,x%29%3B%0A%20%20printf%28%22%25020.3f%5Cn%22,x%29%3B%0A%20%20printf%28%22%25f%5Cn%22,y%29%3B%0A%20%20printf%28%22%25.9f%5Cn%22,y%29%3B%0A%20%20printf%28%22%25.20f%5Cn%22,y%29%3B%0A%20%20printf%28%22%2520.4e%5Cn%22,y%29%3B%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false)). ¿Cual es su salida en pantalla?


#### Caso 3 - Cadenas de caracteres

{numref}`Tabla 6` Usando especificadores para cadenas de caracteres


|Especificador de formato  | Tipo de dato | Ejemplo | Resultado |
|----------------|--------------------------|----|---|
| ```%[alineación][ancho].[Máximo_número_de_caracteres_a_imprimir]s```| ```char[]```   | ```printf("%3.4s\n","Sheridan")```|```Sher```|

**Ejemplo**

Dado el siguiente fragmento de código. ¿Cual es su salida en pantalla?

```{code-block} c
#include <stdio.h>

int main() {
  char s[]="an evil presence";
  printf("%s\n",s);
  printf("%7s\n",s);
  printf("%20s\n",s);
  printf("%-20s\n",s);
  printf("%.5s\n",s);
  printf("%.12s\n",s);
  printf("%15.12s\n",s);
  printf("%-15.12s\n",s);
  printf("%3.12s\n",s);
  return 0;
}
```

### Funcion ```scanf```

La forma de la función se muestra a continuacion:

```{code-block} C
int scanf(const char *format[,arg1,arg2...]);
```

La función ```scanf()``` se usa para leer cualquier tipo de dato predefinido desde el teclado, y convertirlo de forma automática al formato interno adecuado.

Esta funcion lee caracteres desde el flujo de entrada estándar, los interpreta según lo especificado en **format**, y los almacena en los argumentos. Cada argumento debe ser la dirección de la variable donde será almacenado el carácter. Retorna el número de ítems (argumentos) de entrada emparejados con éxito (almacenados). Los identificadores de formato para scanf son los mismos que para printf (ver tabla 3).

```{important}
Cuando el tipo de dato asociado a la variable es simple (```char```, ```int```, etc); se antepone el símbolo apersand (&) a la variable, pues con este símbolo se obtiene la dirección en memoria de la variable (esto será explicado más adelante en el curso), por ejemplo en el siguiente código:
```

```{code-block} c
#include <stdio.h>

int main() {
  int edad;
  float estatura;
  printf("Digite la edad: ");
  scanf("%d", &edad);
  printf("Digite la estatura (en metros): ");
  scanf("%f", &estatura);
  printf("\n------------------------------------------\n");
  printf("Edad: %d\n",edad);
  printf("Estatura %f\n",estatura);
  return 0;
}
```

En el código anterior el ampersand (```&```) es usado antepuesto a las variables ```edad``` y ```estatura``` cuando se emplea la funcion ```scanf```. El programa anterior cuando se ejecuta arroja una salida como la siguiente (para nuestro caso asumimos una edad de 3 años y una estatura de 0.8 m).

```
Digite la edad: 3
Digite la estatura (en metros): 0.8

------------------------------------------
Edad: 3
Estatura 0.800000
```

```{important}
Cuando lo que se ingresa es una cadena de caracteres, no es necesario emplear el ampersand (```&```) pues en C el nombre de una cadena de caracteres se interpreta como una dirección de memoria.
```

El siguiente código muestra lo descrito anteriormente:

```{code-block} c
#include <stdio.h>

int main() {
  char nombre[15]; // Almacena maximo 14 caracteres
  printf("Digite el nombre: ");
  scanf("%s",nombre);
  printf("\nHola: %s\n",nombre);
  return 0;
}
```

Note como en este código no se emplea el ampersand cuando se lee la cadena nombre con el ```scanf``` (a diferentecia de las variables edad y estatura del ejemplo anterior). La salida del programa anterior se muestra a continuacion:

```
Digite el nombre: Ramon

Hola: Ramon
```


Jupyter Book also lets you write text-based notebooks using MyST Markdown.
See [the Notebooks with MyST Markdown documentation](https://jupyterbook.org/file-types/myst-notebooks.html) for more detailed instructions.
This page shows off a notebook written in MyST Markdown.

## An example cell

With MyST Markdown, you can define code cells with a directive like so:

```{code-cell}
print(2 + 2)
```

When your book is built, the contents of any `{code-cell}` blocks will be
executed with your default Jupyter kernel, and their outputs will be displayed
in-line with the rest of your content.

```{seealso}
Jupyter Book uses [Jupytext](https://jupytext.readthedocs.io/en/latest/) to convert text-based files to notebooks, and can support [many other text-based notebook files](https://jupyterbook.org/file-types/jupytext.html).
```

## Create a notebook with MyST Markdown

MyST Markdown notebooks are defined by two things:

1. YAML metadata that is needed to understand if / how it should convert text files to notebooks (including information about the kernel needed).
   See the YAML at the top of this page for example.
2. The presence of `{code-cell}` directives, which will be executed with your book.

That's all that is needed to get started!

## Quickly add YAML metadata for MyST Notebooks

If you have a markdown file and you'd like to quickly add YAML metadata to it, so that Jupyter Book will treat it as a MyST Markdown Notebook, run the following command:

```
jupyter-book myst init path/to/markdownfile.md
```
