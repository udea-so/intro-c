---
jupytext:
  cell_metadata_filter: -all
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Listas enlazadas

```{admonition} Objetivos
* Objetivo 1...
* Objetivo 2...
```

## 1. Introduccion

xxx


## 2. Lista enlazada

Una **pila** (**stack**) es una ADT que permite almacenar y recuperar datos. Esta presenta un modo de acceso a sus elementos de tipo **LIFO** (del inglés **Last In**, **First Out**, último en entrar, primero en salir) debido a que los datos almacenados en ella se retiran en orden inverso al que fueron entrados.

```{figure} ./local/img/CH_02-S06-stack_fig1.png
---
name: stack_fig1
---
Representación y operaciones de una pila (stack)
```

Cuando se trabajan con pilas se manejan las siguientes operaciones básicas:
* **Verificar lista vacia**: Inicia una pila vacia.
* ***

```{admonition} Simulaciones
:class: tip
La pagina **Data Structure Visualizations** ([link](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)) recopila una gran cantidad de animaciones sobre estructuras de datos.
```

### 2.1. Nodo

La siguiente ...

```{code-block} c
typedef struct _node {
    int item;
    struct _node* next;
}node;
```

### 2.2. Lista

La siguiente ...

```{code-block} c
typedef struct _list {
    node *head;
} list;
```

La siguiente figura muestra la estructura asociada a la pila (`stack`) previamente definida:

```{figure} ./local/img/CH_02-S06-stack_fig1a_.png
---
name: stack_fig1a
---
Estructura asociada a la pila (`stack`)
```


### 2.3. Funcionas de la lists

Las operaciones asociadas la ADT `stack` definida previamente se destriben a continuación:

* **`List_new`**: 
  
  ```{code-block} c
  list* List_new(void) {
    list *L = malloc(sizeof(L));
    assert(L != NULL);
    L->head = NULL;
    return L;
  }
  ```

* **`List_init`**: 
  
  ```{code-block} c
  void List_init(list *L) {
    L->head = NULL;
    return L;
  }
  ```

* **`List_empty`**: 

  ```{code-block} c
  int List_empty(list *L) {
    assert(L != NULL);
    return (L->head == NULL);
  }
  ```

* **`List_length`**: 

  ```{code-block} c
  int List_length(list *L) {
    node *current = L->head;
    int count = 0;
    while (current != NULL) {
        count++;
        current = current->next;
    }
    return count;
  }
  ```

* **`List_insert_at_begin`**: .

  ```{code-block} c
  void List_insert_at_begin(list *L, int item) {
    node *new = malloc(sizeof(node));
    assert(new != NULL);
    assert(L != NULL);
    new->item = item;
    if (L->head != NULL) {
        // El resto de los elementos
        new->next = L->head;
        L->head = new;
    }
    else {
        // Primer elemento
        new->next = NULL;
        L->head = new;
    }
  }
  ```

* **`List_insert_at_end`**: 
  
  ```{code-block} c
  void List_insert_at_end(list *L, int item) {
    node *new = malloc(sizeof(node));
    assert(new != NULL);
    assert(L != NULL);
    new->item = item;
    if (L->head == NULL) {
        new->next = L->head;
        L->head = new;
    }
    else {
        node *current = L->head;
        while (current->next != NULL) {
            current = current->next;
        }
        new->next = NULL;
        current->next = new;
    }    
  }
  ```

* **`List_delete_at_begin`**:

  ```{code-block} c
  int List_delete_at_begin(list *L) {    
    if (L->head == NULL) {
        printf("ERROR: Empty List\n");
        return -1;
    }
    else {
        node *current = L->head;
        L->head = current->next;
        free(current);
        return 0;
    }
  }
  ```

* **`List_delete_at_end`**:

  ```{code-block} c
  int List_delete_at_end(list *L) {
    if (L->head == NULL) {
        printf("ERROR: Empty List\n");
        return -1;
    }
    else if(L->head->next == NULL) {
        free(L->head);
        L->head = NULL;
    }
    else {
        node *current = L->head;
        node *prev;
        while(current->next != NULL) {            
            prev = current;
            current = current->next;
        } 
        prev->next = NULL;
        free(current);       
        return 0;
    }
  }
  ```

* **`List_seach`**:
  
  ```{code-block} c
  node* List_search(list *L, int item) {
    node *current = L->head;
    while (current) {
        if (current->item == item) {
            return current; // success
        }
        current = current->next;
    }
    return NULL; // failure
  }
  ```

* **`List_delete`**:
  
  ```{code-block} c
  int List_delete(list *L, int item) {
    // ToDo...
  }
  ```

* **`List_print`**: 

  ```{code-block} c
  void List_print(list *L, int opt) {
    node *current = L->head;
    if (current == NULL) {
        printf("Empty list.\n");
    } 
    else {
        switch (opt)
        {
        case 1:
            while (current) {
                printf("[%d] --> ", current->item);
                current = current->next;
            } 
            printf("[X]\n");
            break;
        case 2:
            for(; current->next != NULL; current = current->next) {
                printf("[%d|%p] --> ", current->item, current->next);
            }
            printf("[%d|%p]\n", current->item, current->next);
            break;
        default:
            printf("Invalid option.\n");            
        }
    } 
  }
  ```


## 3. Uso de la estructura `list`

Recordemos que el **programa cliente** es aquel que hace el llamado de las funciones definidas en bibliotecas, modulos o clases para realizar determinadas tareas. 

En un programa, la función encargada de iniciar la ejecución de este es la función `main`. En esta función, se implementa la logica de la aplicación mediante el llamado a las funciones que han sido previamente definidas tal y como se muestra en la siguiente figura:


```{figure} ./local/img/CH_02-S06-stack_fig1b.png
---
name: stack_fig1a
---
Función `main`
```

El siguiente código, muestra el caso como seria un programa de un solo archivo en el cual se hace uso de la estructura `stack`. Notese que al implementarse la logica de la aplicación función `main`, las instrucciones se definen de acuerdo a los requerimientos de la aplicación.

```{code-block} c 
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

typedef struct _node {
    int item;
    struct _node* next;
}node;

typedef struct _list {
    node *head;
} list;

list* List_new(void);
void List_init(list *);
int List_empty(list *);
void List_insert_at_begin(list *, int);
void List_insert_at_end(list *, int);
void List_print(list *, int);
int List_length(list *);
int List_delete_at_begin(list *);
int List_delete_at_end(list *);
node* List_search(list *, int);
int List_delete(list *, int);

int main() {
    list *L = List_new();
    List_insert_at_begin(L, 1);
    List_print(L,1);
    List_insert_at_begin(L, 2);
    List_insert_at_begin(L, 3);
    List_print(L,2);
    List_insert_at_end(L, 0);
    List_print(L,1);
    List_print(L,2);
    List_delete_at_begin(L);
    List_print(L,1);
    List_delete_at_end(L);
    List_print(L,2);
    List_delete_at_end(L);
    List_print(L,1);
    List_delete_at_end(L);
    List_print(L,1);
    List_insert_at_end(L, 1);
    List_insert_at_end(L, 2);
    List_insert_at_end(L, 3);
    List_print(L,1);
    List_print(L,2);
    return 0;
}


list* List_new(void) {
    list *L = malloc(sizeof(L));
    assert(L != NULL);
    L->head = NULL;
    return L;
}

void List_init(list *L) {
    L->head = NULL;
    return L;
}

int List_empty(list *L) {
    assert(L != NULL);
    return (L->head == NULL);
}

void List_insert_at_begin(list *L, int item) {
    node *new = malloc(sizeof(node));
    assert(new != NULL);
    assert(L != NULL);
    new->item = item;
    if (L->head != NULL) {
        // El resto de los elementos
        new->next = L->head;
        L->head = new;
    }
    else {
        // Primer elemento
        new->next = NULL;
        L->head = new;
    }
}

void List_insert_at_end(list *L, int item) {
    node *new = malloc(sizeof(node));
    assert(new != NULL);
    assert(L != NULL);
    new->item = item;
    if (L->head == NULL) {
        new->next = L->head;
        L->head = new;
    }
    else {
        node *current = L->head;
        while (current->next != NULL) {
            current = current->next;
        }
        new->next = NULL;
        current->next = new;
    }    
}

int List_length(list *L) {
    node *current = L->head;
    int count = 0;
    while (current != NULL) {
        count++;
        current = current->next;
    }
    return count;
}


void List_print(list *L, int opt) {
    node *current = L->head;
    if (current == NULL) {
        printf("Empty list.\n");
    } 
    else {
        switch (opt)
        {
        case 1:
            while (current) {
                printf("[%d] -> ", current->item);
                current = current->next;
            } 
            printf("[X]\n");
            break;
        case 2:
            for(; current->next != NULL; current = current->next) {
                printf("[%d|%p] -> ", current->item, current->next);
            }
            printf("[%d|%p]\n", current->item, current->next);
            break;
        default:
            printf("Invalid option.\n");            
        }
    } 
}

int List_delete_at_begin(list *L) {    
    if (L->head == NULL) {
        printf("ERROR: Empty List\n");
        return -1;
    }
    else {
        node *current = L->head;
        L->head = current->next;
        free(current);
        return 0;
    }
}

int List_delete_at_end(list *L) {
    if (L->head == NULL) {
        printf("ERROR: Empty List\n");
        return -1;
    }
    else if(L->head->next == NULL) {
        free(L->head);
        L->head = NULL;
    }
    else {
        node *current = L->head;
        node *prev;
        while(current->next != NULL) {            
            prev = current;
            current = current->next;
        } 
        prev->next = NULL;
        free(current);       
        return 0;
    }
}

node* List_search(list *L, int item) {
    assert(L != NULL);
    node *current = L->head;
    while (current) {
        if (current->item == item) {
            return current; // success
        }
        current = current->next;
    }
    return NULL; // failure
}

int List_delete(list *L, int item) {
    // ToDo...
}
```

### 3.1. Ejemplos

Asumiendo xxx

1. **Codigo 1**: Mediante código implemente la siguiente pila:
   
   ```{figure} ./local/img/CH_02-S06-stack_fig2.png
   ---
   name: stack_fig2
   ---
   Pila asociada al ejemplo.
   ```
      
   El siguiente fragmento de código hace uso de las funciones definidas anteriormente para:
   * Inicializar una pila (`S`).
   * Agregar tres elementos a la pila: `1`, `2` y `3` respectivamente.
   * Mostrar si la pila esta vacia, llena o parcialmente llena (indicando el numero de elementos que puede se pueden colocar).
   * Mostrar cada vez que se agrega un elemento el valor del tope (`top`) de la pila.
   
   
   
   ```{code-block} c
   ss
   ```

   El resultado del código anterior, se muestra a continuación:

   ```{figure} ./local/img/CH_02-S06-stack_fig2a.png
   ---
   name: stack_fig2a
   ---
   Resultado código anterior
   ```

2. **Codigo 2**: Partiendo de la lista de 3 elementos anteriormente mostrada, saque el ultimo elemento agregado tal y como se muestra en la siguiente figura:
   
   ```{figure} ./local/img/CH_02-S06-stack_fig3.png
   ---
   name: stack_fig3
   ---
   Pila asociada al ejemplo anterior
   ```
   
   La implementación realizada en el siguiente fragmento de código ([simulacion](https://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%23include%20%3Cstdlib.h%3E%0A%23include%20%3Cassert.h%3E%0A%0A%23define%20CAPACITY%203%0A%0Atypedef%20struct%20_stack%20%7B%0A%20%20int%20count%3B%0A%20%20int%20data%5BCAPACITY%5D%3B%0A%7D%20stack%3B%0A%0Avoid%20stack_init%28stack%20*s%29%3B%0Aint%20stack_empty%28stack%20*s%29%3B%0Avoid%20stack_push%28stack%20*s,%20int%20item%29%3B%0Aint%20stack_pop%28stack%20*s%29%3B%0Aint%20stack_full%28stack%20*s%29%3B%0Aint%20stack_peek%28stack%20*s%29%3B%0A%0Aint%20main%28%29%20%7B%0A%20%20stack%20S%3B%0A%20%20stack_init%28%26S%29%3B%20%20%20%20//%20S%20%3D%20%5B%20%5D%20%3A%20Lista%20vacia%0A%20%20stack_push%28%26S,%201%29%3B%20//%20S%20%3D%20%5B%7Ctop%7C-%3E%201%5D%0A%20%20stack_push%28%26S,%202%29%3B%20//%20S%20%3D%20%5B%7Ctop%7C-%3E%202%20,%201%5D%0A%20%20stack_push%28%26S,%203%29%3B%20//%20S%20%3D%20%5B%7Ctop%7C-%3E%203,%202%20,%201%5D%0A%20%20int%20e%20%3D%20stack_pop%28%26S%29%3B%20//%20S%20%3D%20%5B%7Ctop%7C-%3E%202%20,%201%5D%20%3B%20e%20%3D%203%0A%20%20printf%28%22Elemento%20sacado%20de%20la%20pila%3A%20%25d%5Cn%22,%20e%29%3B%0A%20%20printf%28%22Elementos%20disponibles%20en%20la%20pila%3A%20%25d%20%5Cn%22,%20%20S.count%29%3B%0A%20%20return%200%3B%0A%7D%0A%0Avoid%20stack_init%28stack%20*s%29%20%7B%20%0A%20%20s-%3Ecount%20%3D%200%3B%0A%7D%0A%0Aint%20stack_empty%28stack%20*s%29%20%7B%0A%20%20assert%28s%20!%3D%20NULL%29%3B%0A%20%20return%20%28s-%3Ecount%20%3D%3D%200%29%3B%0A%7D%0A%0Avoid%20stack_push%28stack%20*s,%20int%20item%29%20%7B%0A%20%20assert%28s%20!%3D%20NULL%29%3B%0A%20%20assert%28s-%3Ecount%20%3C%20CAPACITY%29%3B%0A%20%20s-%3Edata%5Bs-%3Ecount%5D%20%3D%20item%3B%0A%20%20s-%3Ecount%2B%2B%3B%0A%7D%0A%0Aint%20stack_pop%28stack%20*s%29%20%7B%0A%20%20assert%28s%20!%3D%20NULL%29%3B%0A%20%20assert%28s-%3Ecount%20%3E%200%29%3B%0A%20%20s-%3Ecount--%3B%0A%20%20return%20s-%3Edata%5Bs-%3Ecount%5D%3B%0A%7D%0A%0Aint%20stack_full%28stack%20*s%29%20%7B%0A%20%20assert%28s%20!%3D%20NULL%29%3B%0A%20%20return%20%28s-%3Ecount%20%3D%3D%20CAPACITY%29%3B%0A%7D%0A%0Aint%20stack_peek%28stack%20*s%29%20%7B%0A%20%20assert%28s%20!%3D%20NULL%29%3B%0A%20%20int%20top%20%3D%20s-%3Edata%5Bs-%3Ecount%20-%201%5D%3B%0A%20%20return%20top%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false)) hace lo siguiente:
   * Inicializa la pila al estado inicial (`1`, `2` y `3`).
   * Saca el ultimo elemento ingresado a la pila (`3`) imprimiendo su valor.
   * Muestra la cantidad de elementos que quedan en la pila.
   
   ```{code-block} c
   #include <stdio.h>
   #include <stdlib.h>
   #include <assert.h>

   #define CAPACITY 3

   typedef struct _stack {
     int count;
     int data[CAPACITY];
   } stack;

   // Declaración de funciones
   // Codigo declaración...

   
   // Codigo main
   int main() {
     stack S;
     stack_init(&S);    // S = [ ] : Lista vacia
     stack_push(&S, 1); // S = [|top|-> 1]
     stack_push(&S, 2); // S = [|top|-> 2 , 1]
     stack_push(&S, 3); // S = [|top|-> 3, 2 , 1]
     int e = stack_pop(&S); // S = [|top|-> 2 , 1] ; e = 3
     printf("Elemento sacado de la pila: %d\n", e);
     printf("Elementos disponibles en la pila: %d \n",  S.count);
     return 0;
   }

   // Definición de funciones
   // Codigo definición...
   ```
   
   La salida del fragmento de código anterior, se muestra a continuación:

   ```{figure} ./local/img/CH_02-S06-stack_fig3a.png
   ---
   name: stack_fig3
   ---
   Resultado código anterior
   ```
   
## 4. Enlaces

* https://ranger.uta.edu/~alex/courses/3318/
* https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
* http://cslibrary.stanford.edu/
* https://web.stanford.edu/dept/cs_edu/resources/textbook/
* https://web.stanford.edu/class/cs106x/handouts.html
* https://web.stanford.edu/class/cs107/
* https://web.stanford.edu/class/archive/cs/cs107/cs107.1248/calendar
* https://web.stanford.edu/class/cs106x/res/reader/CS106BX-Reader.pdf
* http://cslibrary.stanford.edu/
* https://www.cs.swarthmore.edu/~newhall/cs45/s14/#schedule
* https://www.cs.swarthmore.edu/~newhall/unixlinks.html#lang
* https://publications.gbdirect.co.uk/c_book/
* https://www.cs.swarthmore.edu/~newhall/unixlinks.html#Clang
* https://www.cs.swarthmore.edu/~newhall/unixhelp/os_stats.php
* https://www.cs.swarthmore.edu/~newhall/cs35/
* https://www.cs.swarthmore.edu/~newhall/unixhelp/C_linkedlists.pdf
* https://www.cs.princeton.edu/courses/archive/spring20/cos217/ 
* https://www.cs.princeton.edu/courses/archive/spring20/cos217/precepts/09voidptrs/symtablelist.pdf
* https://www.cs.princeton.edu/courses/archive/spring20/cos217/lectures/01_Intro.pdf
* https://august.princeton.edu/
* https://www.cs.princeton.edu/courses/archive/fall07/cos217/lectures/
* https://ocw.mit.edu/courses/6-s096-introduction-to-c-and-c-january-iap-2013/
* https://ocw.mit.edu/courses/6-s096-introduction-to-c-and-c-january-iap-2013/pages/lectures-and-assignments/data-structures-debugging/
* https://ocw.mit.edu/courses/6-s096-introduction-to-c-and-c-january-iap-2013/pages/lectures-and-assignments/data-structures-debugging/
* https://ocw.mit.edu/courses/6-033-computer-system-engineering-spring-2018/
* https://ocw.mit.edu/courses/6-828-operating-system-engineering-fall-2012/
* https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/
* https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/pages/lecture-notes/
* https://ocw.mit.edu/courses/1-00-introduction-to-computers-and-engineering-problem-solving-spring-2012/
* https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/
* https://ocw.mit.edu/courses/6-100l-introduction-to-cs-and-programming-using-python-fall-2022/
* https://ocw.mit.edu/collections/introductory-programming/
* https://cs61c.org/su24/
* https://www.cs.princeton.edu/courses/archive/spr24/cos126/schedule/
* https://web2.qatar.cmu.edu/~mhhammou/15122-s23/
* https://web2.qatar.cmu.edu/~mhhammou/15122-s23/schedule.html
* https://bytesoftheday.wordpress.com/2014/07/04/q14/
* https://www.cs.princeton.edu/courses/archive/spring20/cos217/
* https://embeddedwala.com/Blogs/embedded-c/memory-layout-of-c-program
* https://www.cs.mtsu.edu/~cs2170/C++labs/lab18/OSmemlayout.pdf
* https://d1b10bmlvqabco.cloudfront.net/attach/j6fe5friemd22w/hzd1madqsie3ts/j7kw6i4tmqf8/61C_Note_1_Memory.pdf
* https://ocw.mit.edu/courses/6-s096-introduction-to-c-and-c-january-iap-2013/bba9056d5290198d563edc47dfcff0e9_MIT6_S096_IAP13_lec3.pdf
* https://cs61c.org/su24/
* http://wla.berkeley.edu/~cs61c/fa17/
* https://www.cs.princeton.edu/courses/archive/fall07/cos217/index.html
* https://web2.qatar.cmu.edu/~mhhammou/15122-s23/lectures/21-cmem/writeup/pdf/main.pdf
* https://cs.gmu.edu/~zduric/cs262/Slides/teoX.pdf
* https://d1b10bmlvqabco.cloudfront.net/attach/j6fe5friemd22w/hzd1madqsie3ts/j7kw6i4tmqf8/61C_Note_1_Memory.pdf
* https://www.cs.princeton.edu/courses/archive/fall07/cos217/
* https://www.cs.mtsu.edu/~cs2170/C++labs/lab18/OSmemlayout.pdf
* https://web2.qatar.cmu.edu/~mhhammou/15122-s23/lectures/21-cmem/writeup/pdf/main.pdf
* https://www.cs.princeton.edu/courses/archive/spr24/cos126/schedule/
* https://github.com/vishwa27yvs/Intro-to-Computer-Science-COS-126
* https://www.berthon.eu/wiki/foss:wikishelf:linux:memory
* http://resources.infosecinstitute.com/system-address-map-initialization-in-x86x64-architecture-part-1-pci-based-systems/#gref
* https://fypandroid.wordpress.com/2011/01/17/anatomy-of-a-program-in-memory/
* https://www.securitysift.com/windows-exploit-development-part-1-basics/
* https://www.ibm.com/developerworks/library/j-nativememory-linux/
* https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/in-memory-layout/
* http://www.cs.utexas.edu/users/fussell/cs310h/lectures/Lecture_17-310h.pdf
* https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-087-practical-programming-in-c-january-iap-2010/lecture-notes/
* https://stackoverflow.com/questions/2128728/allocate-matrix-in-c
* https://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/
* https://www.programiz.com/c-programming/c-dynamic-memory-allocation
* https://www.cs.swarthmore.edu/~newhall/unixhelp/C_arrays.html

