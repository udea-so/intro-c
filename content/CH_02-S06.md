---
jupytext:
  cell_metadata_filter: -all
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Estructuras de datos

```{admonition} Objetivos
* Objetivo 1...
* Objetivo 2...
```

## 1. Introduccion

En los programas tipicos, la cantidad de memoria que usan es desconocida. xx



## 2. Mapa de memoria

Cuando un programa es cargado en memoria, este se organiza en diferentes regiones memoria conocidas como **segmentos** que se usan para diferentes propositos.

```{figure} ./local/img/CH_02-S05-fig1_3.png
---
name: fig1
---
Mapa de memoria (Memory Layout)
```

## Listas enlazadas



## Stack

### Stack con arrays

#### Estructura


```{code-block} c
#define CAPACITY 10

typedef struct _stack {
  int count;
  int data[CAPACITY];
} stack;
```


#### Funciones

**Inicialización**:

```{code-block} c
stack *stack_init(void) { 
  stack *s = malloc(sizeof(s));
  assert(s!= NULL);
  s->count = 0;
  return s;
}
```

**empty**:

```{code-block} c
int stack_empty(stack *s) {
  assert(s != NULL);
  return (s->count == 0);
}
```

**push**:

```{code-block} c
void stack_push(stack *s, int item) {
  assert(s != NULL);
  assert(s->count < CAPACITY);
  s->data[s->count] = item;
  s->count++;
}
```

**pop**:

```{code-block} c
int stack_pop(stack *s) {
  assert(s != NULL);
  assert(s->count > 0);
  s->count--;
  return s->data[s->count];
}
```

**completo**:

```{code-block} c
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define CAPACITY 10

typedef struct _stack {
  int count;
  int data[CAPACITY];
} stack;

stack *stack_init(void);
int stack_empty(stack *);
void stack_push(stack *, int);
int stack_pop(stack *);
void print_stack(stack *s);

int main() {
  printf("Enlace\n");
  stack *S = stack_init(); // _
  stack_push(S, 1);  // 1
  stack_push(S, 2);  // 2 1
  stack_push(S, 3);  // 3 2 1
  stack_push(S, 4);  // 4 3 2 1
  printf("valor sacado = %d\n",stack_pop(S)); // 3 2 1
  printf("valor sacado = %d\n",stack_pop(S)); // 2 1 
  printf("valor sacado = %d\n",stack_pop(S)); // 1
  printf("valor sacado = %d\n",stack_pop(S)); // _
  printf("valor sacado = %d\n",stack_pop(S));
  return 0;
}

stack *stack_init(void) { 
  stack *s = malloc(sizeof(s));
  assert(s!= NULL);
  s->count = 0;
  return s;
}

int stack_empty(stack *s) {
  assert(s != NULL);
  return (s->count == 0);
}

void stack_push(stack *s, int item) {
  assert(s != NULL);
  assert(s->count < CAPACITY);
  s->data[s->count] = item;
  s->count++;
}

int stack_pop(stack *s) {
  assert(s != NULL);
  assert(s->count > 0);
  s->count--;
  return s->data[s->count];
}
```



### Ejemplos

#### Ejemplo 1

Simule el siguiente código y analice en como sería el mapa de memoria asociado al programa.

```{code-block} c
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define CAPACITY 10

typedef struct _stack {
  int count;
  int data[CAPACITY];
} stack;

stack *stack_init(void);

int main() {
  printf("Enlace\n");
  stack *S = stack_init();
  return 0;
}

stack *stack_init(void) { 
  stack *stk = malloc(sizeof(stk));
  assert(stk!= NULL);
  stk->count = 0;
  return stk;
}
```


La simulación se puede realizar a continuación:

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0A%0Aint%20x%3D5%3B%0Achar%20msg%5B%5D%20%3D%20%22Hello%22%3B%0A%0Aint%20main%28int%20argc,%20const%20char*%20argv%5B%5D%29%20%7B%0A%20%20int%20v%3B%0A%20%20float%20pi%20%3D%203.14159%3B%0A%20%20printf%28%22%25d%5Cn%22,x%29%3B%0A%20%20printf%28%22%25f%5Cn%22,pi%29%3B%0A%20%20return%200%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>

El resultado de la simulación se muestra a continuación:

```{figure} ./local/img/CH_02-S05-fig3.png
---
name: fig3
---
Salida del programa.
```

Como se puede ver de la figura anterior, se resaltan los espacios de memoria y las variables que se encuentran en estos:

|Espacio de memoria |	Variables |
|----|----|
|**Text**|Instrucciones|
|**Data**|`x`, `msg`|
|**Stack**|`argc`, `argv`, `v`, `pi`|
|**Heap**|---|

En la siguiente figura se muestra mas claramente como se distribuyen las variables anteriores en el mapa de memoria:

```{figure} ./local/img/CH_02-S05-fig4.png
---
name: fig4
---
Asignacion de las variables en el espacio de memoria.
```

En la figura anterior, se puede ver que no hay variables en el **heap** pues no se hicieron asignaciones dinamicas de memoria el cual sera el proximo tema a tratar.

#### Ejemplo 2

Dado el siguiente código (tomado del documento **Memory & C** ([link](https://d1b10bmlvqabco.cloudfront.net/attach/j6fe5friemd22w/hzd1madqsie3ts/j7kw6i4tmqf8/61C_Note_1_Memory.pdf))) como seria el mapa de memoria asociado.

```{code-block} c
#include <stdio.h>
#include <stdlib.h>

int z = -1;

int main(int argc, char* argv) {
    int x = 3 * sizeof(int);
    char* s_static = "61C";
    char s_stack[4];
    s_stack[0] = '6';
    s_stack[1] = '1';
    s_stack[2] = 'B';
    s_stack[3] = '\0';
    int *heap_arr = (int *)malloc(x);
    heap_arr[0] = 1;
    heap_arr[1] = 2;
    heap_arr[2] = 4;
}
```

El programa se puede simular a continuación:

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0A%23include%20%3Cstdlib.h%3E%0A%0Aint%20z%20%3D%20-1%3B%0A%0Aint%20main%28int%20argc,%20char*%20argv%29%20%7B%0A%20%20%20%20int%20x%20%3D%203%20*%20sizeof%28int%29%3B%0A%20%20%20%20char*%20s_static%20%3D%20%2261C%22%3B%0A%20%20%20%20char%20s_stack%5B4%5D%3B%0A%20%20%20%20s_stack%5B0%5D%20%3D%20'6'%3B%0A%20%20%20%20s_stack%5B1%5D%20%3D%20'1'%3B%0A%20%20%20%20s_stack%5B2%5D%20%3D%20'B'%3B%0A%20%20%20%20s_stack%5B3%5D%20%3D%20'%5C0'%3B%0A%20%20%20%20int%20*heap_arr%20%3D%20%28int%20*%29malloc%28x%29%3B%0A%20%20%20%20heap_arr%5B0%5D%20%3D%201%3B%0A%20%20%20%20heap_arr%5B1%5D%20%3D%202%3B%0A%20%20%20%20heap_arr%5B2%5D%20%3D%204%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&cppShowMemAddrs=true&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>

La siguiente figura muestra el resultado de la simulación:

```{figure} ./local/img/CH_02-S05-fig5.png
---
name: fig5
---
Asignacion de las variables en el espacio de memoria.
```

## x. Miselanea de ejemplos

1. Usando `malloc` crear la matriz irregular (jagged arrays) mostrada en la siguiente figura:
   
   ```{figure} ./local/img/CH_02-S05-fig16.png
   ---
   name: fig16
   ---
   Matriz irregular.
   ```
   
   ```{code-block} c
   #include <stdio.h>
   #include <stdlib.h>

   int main() {
     int F = 3;
     int C[] = {4,2,3};
     int val = 0;
  
     // Reserva de espacio para la matriz irregular en el heap
     int** jagged_array = (int **)malloc(F*sizeof(int *));
     for(int i = 0; i < F; i++) {
       // jagged_array[i] = (int *)malloc(C[i]*sizeof(int));
       *(jagged_array + i) = (int *)malloc(C[i]*sizeof(int));
     }
  
     // Llenado de la matriz irregular
     for(int i = 0; i < F; i++) {
       for(int j = 0; j < C[i]; j++) {
         // jagged_array[i][j] = ++val;
         *(*(jagged_array + i) + j) = ++val;
         // printf("%d ", jagged_array[i][j]);
         printf("%d ",*(*(jagged_array + i) + j));
       }
       printf("\n");
     }
  
     // Liberacion del espacio en el heap asociado a la matriz irregular
     for(int i = 0; i < F; i++) {
       free(*(jagged_array + i));
       *(jagged_array + i) = NULL;
     }  
     free(jagged_array);
     jagged_array = NULL;
  
     return 0;
   }
   ```

   La simulación del código anterior se puede realizar a continuación:

   <iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%20%3Cstdio.h%3E%0A%23include%20%3Cstdlib.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20int%20F%20%3D%203%3B%0A%20%20int%20C%5B%5D%20%3D%20%7B4,2,3%7D%3B%0A%20%20int%20val%20%3D%200%3B%0A%20%20%0A%20%20//%20Reserva%20de%20espacio%20para%20la%20matriz%20irregular%20en%20el%20heap%0A%20%20int**%20jagged_array%20%3D%20%28int%20**%29malloc%28F*sizeof%28int%20*%29%29%3B%0A%20%20for%28int%20i%20%3D%200%3B%20i%20%3C%20F%3B%20i%2B%2B%29%20%7B%0A%20%20%20%20//%20jagged_array%5Bi%5D%20%3D%20%28int%20*%29malloc%28C%5Bi%5D*sizeof%28int%29%29%3B%0A%20%20%20%20*%28jagged_array%20%2B%20i%29%20%3D%20%28int%20*%29malloc%28C%5Bi%5D*sizeof%28int%29%29%3B%0A%20%20%7D%0A%20%20%0A%20%20//%20Llenado%20de%20la%20matriz%20irregular%0A%20%20for%28int%20i%20%3D%200%3B%20i%20%3C%20F%3B%20i%2B%2B%29%20%7B%0A%20%20%20%20for%28int%20j%20%3D%200%3B%20j%20%3C%20C%5Bi%5D%3B%20j%2B%2B%29%20%7B%0A%20%20%20%20%20%20//%20jagged_array%5Bi%5D%5Bj%5D%20%3D%20%2B%2Bval%3B%0A%20%20%20%20%20%20*%28*%28jagged_array%20%2B%20i%29%20%2B%20j%29%20%3D%20%2B%2Bval%3B%0A%20%20%20%20%20%20//%20printf%28%22%25d%20%22,%20jagged_array%5Bi%5D%5Bj%5D%29%3B%0A%20%20%20%20%20%20printf%28%22%25d%20%22,*%28*%28jagged_array%20%2B%20i%29%20%2B%20j%29%29%3B%0A%20%20%20%20%7D%0A%20%20%20%20printf%28%22%5Cn%22%29%3B%0A%20%20%7D%0A%20%20%0A%20%20//%20Liberacion%20del%20espacio%20en%20el%20heap%20asociado%20a%20la%20matriz%20irregular%0A%20%20for%28int%20i%20%3D%200%3B%20i%20%3C%20F%3B%20i%2B%2B%29%20%7B%0A%20%20%20%20free%28*%28jagged_array%20%2B%20i%29%29%3B%0A%20%20%20%20*%28jagged_array%20%2B%20i%29%20%3D%20NULL%3B%0A%20%20%7D%20%20%0A%20%20free%28jagged_array%29%3B%0A%20%20jagged_array%20%3D%20NULL%3B%0A%20%20%0A%20%20return%200%3B%0A%7D&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false"> </iframe>

## 6. Enlaces


* https://ranger.uta.edu/~alex/courses/3318/
* https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
* http://cslibrary.stanford.edu/
* https://web.stanford.edu/dept/cs_edu/resources/textbook/
* https://web.stanford.edu/class/cs106x/handouts.html
* https://web.stanford.edu/class/cs107/
* https://web.stanford.edu/class/archive/cs/cs107/cs107.1248/calendar
* https://web.stanford.edu/class/cs106x/res/reader/CS106BX-Reader.pdf
* http://cslibrary.stanford.edu/


----

* https://www.cs.swarthmore.edu/~newhall/cs45/s14/#schedule
* https://www.cs.swarthmore.edu/~newhall/unixlinks.html#lang
* https://publications.gbdirect.co.uk/c_book/
* https://www.cs.swarthmore.edu/~newhall/unixlinks.html#Clang
* https://www.cs.swarthmore.edu/~newhall/unixhelp/os_stats.php
* https://www.cs.swarthmore.edu/~newhall/cs35/
* https://www.cs.swarthmore.edu/~newhall/unixhelp/C_linkedlists.pdf

----
* https://www.cs.princeton.edu/courses/archive/spring20/cos217/ 
* https://www.cs.princeton.edu/courses/archive/spring20/cos217/precepts/09voidptrs/symtablelist.pdf
* https://www.cs.princeton.edu/courses/archive/spring20/cos217/lectures/01_Intro.pdf
* https://august.princeton.edu/
* https://www.cs.princeton.edu/courses/archive/fall07/cos217/lectures/
* 
----

* https://ocw.mit.edu/courses/6-s096-introduction-to-c-and-c-january-iap-2013/
* https://ocw.mit.edu/courses/6-s096-introduction-to-c-and-c-january-iap-2013/pages/lectures-and-assignments/data-structures-debugging/
* https://ocw.mit.edu/courses/6-s096-introduction-to-c-and-c-january-iap-2013/pages/lectures-and-assignments/data-structures-debugging/
* https://ocw.mit.edu/courses/6-033-computer-system-engineering-spring-2018/
* https://ocw.mit.edu/courses/6-828-operating-system-engineering-fall-2012/
* https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/
* https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/pages/lecture-notes/
* https://ocw.mit.edu/courses/1-00-introduction-to-computers-and-engineering-problem-solving-spring-2012/
* https://ocw.mit.edu/courses/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/
* https://ocw.mit.edu/courses/6-100l-introduction-to-cs-and-programming-using-python-fall-2022/
* https://ocw.mit.edu/collections/introductory-programming/

----

* https://cs61c.org/su24/
* https://www.cs.princeton.edu/courses/archive/spr24/cos126/schedule/
* 
---- 

* https://web2.qatar.cmu.edu/~mhhammou/15122-s23/
* https://web2.qatar.cmu.edu/~mhhammou/15122-s23/schedule.html
* 

* https://bytesoftheday.wordpress.com/2014/07/04/q14/
* https://www.cs.princeton.edu/courses/archive/spring20/cos217/
* https://embeddedwala.com/Blogs/embedded-c/memory-layout-of-c-program
* https://www.cs.mtsu.edu/~cs2170/C++labs/lab18/OSmemlayout.pdf
* https://d1b10bmlvqabco.cloudfront.net/attach/j6fe5friemd22w/hzd1madqsie3ts/j7kw6i4tmqf8/61C_Note_1_Memory.pdf
* https://ocw.mit.edu/courses/6-s096-introduction-to-c-and-c-january-iap-2013/bba9056d5290198d563edc47dfcff0e9_MIT6_S096_IAP13_lec3.pdf
* https://cs61c.org/su24/
* http://wla.berkeley.edu/~cs61c/fa17/
* https://www.cs.princeton.edu/courses/archive/fall07/cos217/index.html
* https://web2.qatar.cmu.edu/~mhhammou/15122-s23/lectures/21-cmem/writeup/pdf/main.pdf
* https://cs.gmu.edu/~zduric/cs262/Slides/teoX.pdf
* https://d1b10bmlvqabco.cloudfront.net/attach/j6fe5friemd22w/hzd1madqsie3ts/j7kw6i4tmqf8/61C_Note_1_Memory.pdf
* https://www.cs.princeton.edu/courses/archive/fall07/cos217/
* https://www.cs.mtsu.edu/~cs2170/C++labs/lab18/OSmemlayout.pdf
* https://web2.qatar.cmu.edu/~mhhammou/15122-s23/lectures/21-cmem/writeup/pdf/main.pdf
* https://www.cs.princeton.edu/courses/archive/spr24/cos126/schedule/
* https://github.com/vishwa27yvs/Intro-to-Computer-Science-COS-126
* https://www.berthon.eu/wiki/foss:wikishelf:linux:memory
* http://resources.infosecinstitute.com/system-address-map-initialization-in-x86x64-architecture-part-1-pci-based-systems/#gref
* https://fypandroid.wordpress.com/2011/01/17/anatomy-of-a-program-in-memory/
* https://www.securitysift.com/windows-exploit-development-part-1-basics/
* https://www.ibm.com/developerworks/library/j-nativememory-linux/
* https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/in-memory-layout/
* http://www.cs.utexas.edu/users/fussell/cs310h/lectures/Lecture_17-310h.pdf
* https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-087-practical-programming-in-c-january-iap-2010/lecture-notes/
* https://stackoverflow.com/questions/2128728/allocate-matrix-in-c
* https://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/
* https://www.programiz.com/c-programming/c-dynamic-memory-allocation
* https://www.cs.swarthmore.edu/~newhall/unixhelp/C_arrays.html

